// Source: https://github.com/tsndr/cloudflare-worker-jwt/blob/e7964b63c2cb128bb4ef6b267405c27243819540/index.js

import {atob, btoa} from '@alinea/core/util/Base64'

class Base64URL {
  static parse(s: string) {
    return new Uint8Array(
      [...atob(s.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, ''))].map(
        c => c.charCodeAt(0)
      )
    )
  }
  static stringify(a: Uint8Array) {
    return btoa(String.fromCharCode.apply(0, [...a]))
      .replace(/=/g, '')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
  }
}

let subtle =
  typeof crypto === 'undefined' ? undefined : Promise.resolve(crypto.subtle)

if (!subtle)
  subtle = import('node:crypto')
    .then((c: any) => c.webcrypto.subtle)
    .catch(() => {
      return import('@peculiar/webcrypto').then(
        c => new c.Crypto().subtle as any
      )
    })
    .catch(() => undefined)

const algorithms = {
  ES256: {name: 'ECDSA', namedCurve: 'P-256', hash: {name: 'SHA-256'}},
  ES384: {name: 'ECDSA', namedCurve: 'P-384', hash: {name: 'SHA-384'}},
  ES512: {name: 'ECDSA', namedCurve: 'P-512', hash: {name: 'SHA-512'}},
  HS256: {name: 'HMAC', hash: {name: 'SHA-256'}},
  HS384: {name: 'HMAC', hash: {name: 'SHA-384'}},
  HS512: {name: 'HMAC', hash: {name: 'SHA-512'}},
  RS256: {name: 'RSASSA-PKCS1-v1_5', hash: {name: 'SHA-256'}},
  RS384: {name: 'RSASSA-PKCS1-v1_5', hash: {name: 'SHA-384'}},
  RS512: {name: 'RSASSA-PKCS1-v1_5', hash: {name: 'SHA-512'}}
}

type SignOptions = {
  algorithm: keyof typeof algorithms
  keyid?: string
  header: Record<string, any>
}

type VerifyOptions = {
  algorithm: keyof typeof algorithms
}

class JWT {
  constructor() {}
  _utf8ToUint8Array(str: string) {
    return Base64URL.parse(btoa(unescape(encodeURIComponent(str))))
  }
  _str2ab(str: string) {
    const buf = new ArrayBuffer(str.length)
    const bufView = new Uint8Array(buf)
    for (let i = 0, strLen = str.length; i < strLen; i++) {
      bufView[i] = str.charCodeAt(i)
    }
    return buf
  }
  _decodePayload(raw: string) {
    switch (raw.length % 4) {
      case 0:
        break
      case 2:
        raw += '=='
        break
      case 3:
        raw += '='
        break
      default:
        throw new Error('Illegal base64url string!')
    }
    try {
      return JSON.parse(decodeURIComponent(escape(atob(raw))))
    } catch {
      return null
    }
  }

  /**
   * Signs a payload and returns the token
   *
   * @param {object} payload The payload object. To use `nbf` (Not Before) and/or `exp` (Expiration Time) add `nbf` and/or `exp` to the payload.
   * @param {string} secret A string which is used to sign the payload.
   * @param {JWTSignOptions | JWTAlgorithm} options The options object or the algorithm.
   * @throws {Error} If there's a validation issue.
   * @returns {Promise<string>} Returns token as a `string`.
   */
  sign = async (
    payload: Record<string, any>,
    secret: string,
    options: SignOptions = {algorithm: 'HS256', header: {typ: 'JWT'}}
  ): Promise<string> => {
    const crypto = await subtle
    if (!crypto) throw new Error('Crypto not supported')
    if (typeof options === 'string')
      options = {algorithm: options, header: {typ: 'JWT'}}
    if (payload === null || typeof payload !== 'object')
      throw new Error('payload must be an object')
    if (typeof secret !== 'string') throw new Error('secret must be a string')
    if (typeof options.algorithm !== 'string')
      throw new Error('options.algorithm must be a string')
    const importAlgorithm = algorithms[options.algorithm]
    if (!importAlgorithm) throw new Error('algorithm not found')
    payload.iat = Math.floor(Date.now() / 1000)
    const payloadAsJSON = JSON.stringify(payload)
    const partialToken = `${Base64URL.stringify(
      this._utf8ToUint8Array(
        JSON.stringify({
          ...options.header,
          alg: options.algorithm,
          kid: options.keyid
        })
      )
    )}.${Base64URL.stringify(this._utf8ToUint8Array(payloadAsJSON))}`
    let keyFormat: 'raw' | 'pkcs8' = 'raw'
    let keyData
    if (secret.startsWith('-----BEGIN')) {
      keyFormat = 'pkcs8'
      keyData = this._str2ab(
        atob(
          secret
            .replace(/-----BEGIN.*?-----/g, '')
            .replace(/-----END.*?-----/g, '')
            .replace(/\s/g, '')
        )
      )
    } else keyData = this._utf8ToUint8Array(secret)
    const key = await crypto.importKey(
      keyFormat,
      keyData,
      importAlgorithm,
      false,
      ['sign']
    )
    const signature = await crypto.sign(
      importAlgorithm,
      key,
      this._utf8ToUint8Array(partialToken)
    )
    return `${partialToken}.${Base64URL.stringify(new Uint8Array(signature))}`
  }

  /**
   * Verifies the integrity of the token and returns a boolean value.
   *
   * @param {string} token The token string generated by `jwt.sign()`.
   * @param {string} secret The string which was used to sign the payload.
   * @param {JWTVerifyOptions | JWTAlgorithm} options The options object or the algorithm.
   * @throws {Error | string} Throws an error `string` if the token is invalid or an `Error-Object` if there's a validation issue.
   * @returns {Promise<boolean>} Returns `true` if signature, `nbf` (if set) and `exp` (if set) are valid, otherwise returns `false`.
   */
  verify = async <T>(
    token: string,
    secret: string,
    options: VerifyOptions = {algorithm: 'HS256'}
  ): Promise<T> => {
    const crypto = await subtle
    if (!crypto) throw new Error('Crypto not supported')
    if (typeof token !== 'string') throw new Error('token must be a string')
    if (typeof secret !== 'string') throw new Error('secret must be a string')
    if (typeof options.algorithm !== 'string')
      throw new Error('options.algorithm must be a string')
    const tokenParts = token.split('.')
    if (tokenParts.length !== 3)
      throw new Error('token must consist of 3 parts')
    const importAlgorithm = algorithms[options.algorithm]
    if (!importAlgorithm) throw new Error('algorithm not found')
    const payload = this.decode(token)
    if (payload.nbf && payload.nbf > Math.floor(Date.now() / 1000)) {
      throw 'NOT_YET_VALID'
    }
    if (payload.exp && payload.exp <= Math.floor(Date.now() / 1000)) {
      throw 'EXPIRED'
    }
    let keyFormat: 'raw' | 'pkcs8' = 'raw'
    let keyData
    if (secret.startsWith('-----BEGIN')) {
      keyFormat = 'pkcs8'
      keyData = this._str2ab(
        atob(
          secret
            .replace(/-----BEGIN.*?-----/g, '')
            .replace(/-----END.*?-----/g, '')
            .replace(/\s/g, '')
        )
      )
    } else keyData = this._utf8ToUint8Array(secret)
    const key = await crypto.importKey(
      keyFormat,
      keyData,
      importAlgorithm,
      false,
      ['sign']
    )
    const res = await crypto.sign(
      importAlgorithm,
      key,
      this._utf8ToUint8Array(tokenParts.slice(0, 2).join('.'))
    )
    const isValid = Base64URL.stringify(new Uint8Array(res)) === tokenParts[2]
    if (!isValid) throw 'INVALID'
    return payload
  }

  private decode(token: string) {
    return this._decodePayload(
      token.split('.')[1].replace(/-/g, '+').replace(/_/g, '/')
    )
  }
}

export const {sign, verify} = new JWT()
