import {createHash} from 'node:crypto'
import {mkdtemp, readFile, readdir, rm, writeFile} from 'node:fs/promises'
import {tmpdir} from 'node:os'
import {join} from 'node:path'
import {inflateSync} from 'node:zlib'
import {Blob, CompressionStream, Response} from '@alinea/iso'
import {suite} from '@alinea/suite'
import {$} from 'bun'
import {applyGitDelta, createGitDelta} from './GitDelta.js'
import {hashBlob} from './GitUtils.js'
import {concatUint8Arrays, hexToBytes} from './Utils.js'

const test = suite(import.meta)

test('roundtrip create/apply git delta', () => {
  const base = bytes('abc123\nline2\nline3\n')
  const target = bytes('abc123\nline2 updated\nline3\nline4\n')

  const delta = createGitDelta(base, target)
  const applied = applyGitDelta(base, delta)
  test.equal(applied, target)
})

test('encodes large copy op fields (offset2, size1, size2)', () => {
  const offset = 70_000
  const size = 70_123
  const base = new Uint8Array(offset + size + 32)
  for (let i = 0; i < size; i++) base[offset + i] = (i * 31 + 7) & 0xff
  const target = base.slice(offset, offset + size)

  const delta = createGitDelta(base, target)
  const applied = applyGitDelta(base, delta)
  test.equal(applied, target)
})

test('encodes copy size high byte (size2) for very large match', () => {
  const size = 70_500
  const base = new Uint8Array(size)
  for (let i = 0; i < size; i++) base[i] = ((i * 13) ^ (i >>> 3)) & 0xff
  const target = base.slice()

  const delta = createGitDelta(base, target)
  const applied = applyGitDelta(base, delta)
  test.equal(applied, target)
})

test('encodes very large offset copy op field (offset3)', () => {
  const offset = 16_800_000
  const size = 512
  const base = new Uint8Array(offset + size + 16)
  for (let i = 0; i < size; i++) base[offset + i] = (i * 17 + 11) & 0xff
  const target = base.slice(offset, offset + size)

  const delta = createGitDelta(base, target)
  const applied = applyGitDelta(base, delta)
  test.equal(applied, target)
})

test('git accepts pack containing our ref-delta', async () => {
  const base = bytes(`${'a'.repeat(4000)}\n${'b'.repeat(4000)}\n`)
  const target = bytes(`${'a'.repeat(4000)}\n${'c'.repeat(4000)}\nTAIL\n`)

  const baseSha = await hashBlob(base)
  const targetSha = await hashBlob(target)
  const delta = createGitDelta(base, target)

  const pack = await createPackWithRefDelta(baseSha, base, delta)

  const dir = await mkdtemp(join(tmpdir(), 'alinea-git-delta-'))
  try {
    await $`git init --bare`.cwd(dir).quiet()

    const packPath = join(dir, 'test.pack')
    await writeFile(packPath, pack)
    await $`git index-pack --strict --stdin < ${packPath}`.cwd(dir).quiet()

    const content = await $`git cat-file -p ${targetSha}`.cwd(dir).quiet()
    test.equal(new Uint8Array(content.stdout), target)
  } finally {
    await rm(dir, {recursive: true, force: true})
  }
})

test('our apply decodes delta generated by git', async () => {
  const dir = await mkdtemp(join(tmpdir(), 'alinea-git-delta-src-'))
  try {
    await $`git init`.cwd(dir).quiet()

    const baseStr = `${'prefix\n'.repeat(300)}middle-base\n${'suffix\n'.repeat(300)}`
    const targetStr = `${'prefix\n'.repeat(300)}middle-target\nextra\n${'suffix\n'.repeat(300)}`

    await writeFile(join(dir, 'file.txt'), baseStr)
    await $`git add file.txt`.cwd(dir).quiet()
    await $`git -c user.name=test -c user.email=test@example.com commit -m base`
      .cwd(dir)
      .quiet()

    await writeFile(join(dir, 'file.txt'), targetStr)
    await $`git add file.txt`.cwd(dir).quiet()
    await $`git -c user.name=test -c user.email=test@example.com commit -m target`
      .cwd(dir)
      .quiet()

    await $`git repack -adf --depth=50 --window=50`.cwd(dir).quiet()

    const packDir = join(dir, '.git/objects/pack')
    const idxName = (await readdir(packDir)).find(name => name.endsWith('.idx'))
    test.ok(idxName)

    const verify = await $`git verify-pack -v .git/objects/pack/${idxName}`
      .cwd(dir)
      .text()

    const lines = verify
      .trim()
      .split('\n')
      .filter(line => /^[0-9a-f]{40}\s/.test(line))

    const deltaLine = lines.find(line => {
      const parts = line.trim().split(/\s+/)
      return parts.length >= 7 && (parts[1] === 'blob' || parts[1] === 'delta')
    })
    test.ok(deltaLine)

    const parsed = parseVerifyPackLine(deltaLine!)
    test.ok(parsed.baseSha)

    const packName = idxName!.replace(/\.idx$/, '.pack')
    const packBytes = new Uint8Array(await readFile(join(packDir, packName)))

    const nextOffset = findNextObjectOffset(lines, parsed.offset)
    const deltaPayload = extractDeltaPayload(
      packBytes,
      parsed.offset,
      nextOffset ?? packBytes.length - 20
    )

    const baseContent = await $`git cat-file -p ${parsed.baseSha}`.cwd(dir).quiet()
    const targetContent = await $`git cat-file -p ${parsed.sha}`.cwd(dir).quiet()

    const applied = applyGitDelta(
      new Uint8Array(baseContent.stdout),
      new Uint8Array(deltaPayload)
    )
    test.equal(applied, new Uint8Array(targetContent.stdout))
  } finally {
    await rm(dir, {recursive: true, force: true})
  }
})

async function createPackWithRefDelta(
  baseSha: string,
  baseData: Uint8Array,
  deltaData: Uint8Array
): Promise<Uint8Array> {
  const header = new Uint8Array(12)
  header.set(bytes('PACK'), 0)
  writeUint32BE(header, 4, 2)
  writeUint32BE(header, 8, 2)

  const baseEntry = concatUint8Arrays([
    encodePackObjectHeader(3, baseData.length),
    await zlibCompress(baseData)
  ])

  const deltaEntry = concatUint8Arrays([
    encodePackObjectHeader(7, deltaData.length),
    hexToBytes(baseSha),
    await zlibCompress(deltaData)
  ])

  const payload = concatUint8Arrays([header, baseEntry, deltaEntry])
  const checksum = sha1Bytes(payload)
  return concatUint8Arrays([payload, checksum])
}

function encodePackObjectHeader(type: number, size: number): Uint8Array {
  const bytesOut: Array<number> = []
  let n = size >>> 4
  let first = ((type & 0x07) << 4) | (size & 0x0f)
  if (n !== 0) first |= 0x80
  bytesOut.push(first)

  while (n !== 0) {
    let next = n & 0x7f
    n >>>= 7
    if (n !== 0) next |= 0x80
    bytesOut.push(next)
  }

  return Uint8Array.from(bytesOut)
}

function extractDeltaPayload(
  pack: Uint8Array,
  offset: number,
  nextOffset: number
): Uint8Array {
  const {type, pos: afterHeader} = parsePackObjectHeader(pack, offset)
  test.is(type === 6 || type === 7, true)

  let pos = afterHeader
  if (type === 6) {
    // ofs-delta: skip encoded negative offset
    while (true) {
      const byte = pack[pos++]
      if ((byte & 0x80) === 0) break
    }
  } else {
    pos += 20
  }

  const compressed = pack.subarray(pos, nextOffset)
  return new Uint8Array(inflateSync(Buffer.from(compressed)))
}

function parsePackObjectHeader(
  pack: Uint8Array,
  offset: number
): {type: number; size: number; pos: number} {
  let pos = offset
  let byte = pack[pos++]
  const type = (byte >> 4) & 0x07
  let size = byte & 0x0f
  let shift = 4

  while (byte & 0x80) {
    byte = pack[pos++]
    size |= (byte & 0x7f) << shift
    shift += 7
  }

  return {type, size, pos}
}

function parseVerifyPackLine(line: string): {
  sha: string
  offset: number
  baseSha?: string
} {
  const parts = line.trim().split(/\s+/)
  const sha = parts[0]
  const offset = Number(parts[4])
  const baseSha = parts.length >= 7 ? parts[6] : undefined
  return {sha, offset, baseSha}
}

function findNextObjectOffset(
  lines: Array<string>,
  offset: number
): number | undefined {
  const offsets = lines
    .map(line => Number(line.trim().split(/\s+/)[4]))
    .filter(value => Number.isFinite(value) && value > offset)
    .sort((a, b) => a - b)
  return offsets[0]
}

function sha1Bytes(data: Uint8Array): Uint8Array {
  const hash = createHash('sha1')
  hash.update(Buffer.from(data))
  return new Uint8Array(hash.digest())
}

function bytes(input: string): Uint8Array {
  return new TextEncoder().encode(input)
}

function writeUint32BE(target: Uint8Array, offset: number, value: number) {
  const view = new DataView(target.buffer, target.byteOffset, target.byteLength)
  view.setUint32(offset, value, false)
}

async function zlibCompress(data: Uint8Array): Promise<Uint8Array> {
  const blob = new Blob([data])
  const compressed = new Response(
    blob.stream().pipeThrough(new CompressionStream('deflate'))
  )
  return new Uint8Array(await compressed.arrayBuffer())
}
